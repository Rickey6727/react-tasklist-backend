'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CLASS_PREFIX = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _immutabilityHelper = require('immutability-helper');

var _immutabilityHelper2 = _interopRequireDefault(_immutabilityHelper);

var _calc = require('./calc');

var _style = require('./style');

var _style2 = _interopRequireDefault(_style);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * internal classname prefix
 * @type {string}
 */
var CLASS_PREFIX = exports.CLASS_PREFIX = 'react-ja-date-picker__';

/**
 * Define Calender Picker Component
 * @return {ReactComponent} React Component
 */

var DatePicker = function (_Component) {
  _inherits(DatePicker, _Component);

  /**
   * initializ state
   * @public
   * @param  {Props} props given props
   * @return {void}
   */


  /**
   * props type check
   * @type {Object}
   */
  function DatePicker(props) {
    _classCallCheck(this, DatePicker);

    var _this = _possibleConstructorReturn(this, (DatePicker.__proto__ || Object.getPrototypeOf(DatePicker)).call(this, props));

    var tmp = (0, _moment2.default)(_this.props.date);
    var date = tmp.isValid() ? tmp : (0, _moment2.default)();
    _this.state = {
      year: date.year(),
      month: date.month() + 1,
      styles: (0, _calc.normalizeStyle)(_style2.default),
      hovering: false,
      focusing: false
    };
    return _this;
  }

  /**
   * generate static className and style objects
   * @param  {array<string>|string} slug your slug in snake-case
   * @return {{className:string,style:cssInJs}} generated object
   */


  /**
   * default values of props
   * @type {Object}
   */


  _createClass(DatePicker, [{
    key: 'classStyle',
    value: function classStyle(slug) {
      var result = {
        className: CLASS_PREFIX + slug,
        style: this.state.styles[(0, _calc.snake2camel)(slug)]
      };
      return result;
    }

    /**
     * manage hover status
     * @param  {string} id id
     * @return {{onMouseEnter:function,onMouseLeave:function}}  eventHandlers
     */

  }, {
    key: 'enableHover',
    value: function enableHover(id) {
      var _this2 = this;

      return {
        onMouseEnter: function onMouseEnter() {
          return _this2.hoverOn(id);
        },
        onMouseLeave: function onMouseLeave() {
          return _this2.hoverOn(false);
        }
      };
    }

    /**
     * manage focus status
     * @param  {string} id id
     * @return {{onBlur:function,onFocus:function}}  eventHandlers
     */

  }, {
    key: 'enableFocus',
    value: function enableFocus(id) {
      var _this3 = this;

      return {
        onBlur: function onBlur() {
          return _this3.focusOn(false);
        },
        onFocus: function onFocus() {
          return _this3.focusOn(id);
        }
      };
    }

    /**
     * format prop overload with {string} or {function}
     * @param  {number} year  year
     * @param  {number} month month
     * @param  {number} day day
     * @return {string} the aimed URL string
     */

  }, {
    key: 'getURL',
    value: function getURL(year, month, day) {
      var result = typeof this.props.format === 'function' ? format(year, month, day) : // use it as it is
      (0, _calc.strFormat)(this.props.format, { year: year, month: month, day: day }); // use embedded
      return result;
    }

    /**
     * check if a element with certain id is being hovered
     * @param  {string}  id  given id
     * @return {boolean}     whether hoverring
     */

  }, {
    key: 'isHovering',
    value: function isHovering(id) {
      return this.state ? this.state.hovering === id : false;
    }

    /**
     * check if a elelment with certain id is being focused
     * @param  {string}  id given id
     * @return {boolean}    whether focusing
     */

  }, {
    key: 'isFocusing',
    value: function isFocusing(id) {
      return this.state ? this.state.focusing === id : false;
    }

    /**
     * create callback to set hoverirng state
     * @param  {string|boolean} id giving id, or false to cancel it
     * @return {void}
     */

  }, {
    key: 'hoverOn',
    value: function hoverOn(id) {
      this.setState((0, _immutabilityHelper2.default)(this.state, { hovering: { $set: id } }));
    }

    /**
     * create callback to set focusing state
     * @param  {string|boolean} id giving id, or false to cancel it
     * @return {void}
     */

  }, {
    key: 'focusOn',
    value: function focusOn(id) {
      this.setState((0, _immutabilityHelper2.default)(this.state, { focusing: { $set: id } }));
    }

    /**
     * change next month
     * @return {void}
     */

  }, {
    key: 'moveMonthFoward',
    value: function moveMonthFoward() {
      var nYear = this.state.month + 1 > 12 ? this.state.year + 1 : this.state.year;
      var nMonth = this.state.month == 12 ? 1 : this.state.month + 1;
      this.setState((0, _immutabilityHelper2.default)(this.state, { year: { $set: nYear }, month: { $set: nMonth } }));
    }

    /**
     * change prev month
     * @return {void}
     */

  }, {
    key: 'moveMonthBackward',
    value: function moveMonthBackward() {
      var nYear = this.state.month - 1 == 0 ? this.state.year - 1 : this.state.year;
      var nMonth = this.state.month - 1 == 0 ? 12 : this.state.month - 1;
      this.setState((0, _immutabilityHelper2.default)(this.state, { year: { $set: nYear }, month: { $set: nMonth } }));
    }

    /**
     * render
     * @return {ReactComponent} render a calender picker
     */

  }, {
    key: 'render',
    value: function render() {
      var _this4 = this;

      // parse props
      var type = this.props.type;
      var onSelect = this.props.onSelect;

      // parse style object
      var STYLE = (0, _calc.normalizeStyle)(_style2.default);

      // parse state
      var _state = this.state,
          year = _state.year,
          month = _state.month;

      /**
       * render week labels as date picker table head component
       * @type {array<ReactComponent>}
       */

      var headRow = _react2.default.createElement(
        'tr',
        null,
        _react2.default.createElement(
          'th',
          _extends({
            scope: 'row'
          }, this.classStyle('sr-only')),
          '週'
        ),
        _config2.default.weekLabels.ja.map(function (label) {
          return _react2.default.createElement(
            'th',
            _extends({
              key: 'weeklabel-' + label,
              scope: 'col'
            }, _this4.classStyle('week-label')),
            label
          );
        })
      );

      /**
       * 当月の日の情報をまとめたオブジェクトを出力する
       * @type {array<array<{day:number,month:number,active:boolean,weekday:string,isHoliday:boolean}>>}
       */
      var thisMonth = (0, _calc.getMonthCalendar)(year, month);
      var todayUnixSec = (0, _moment2.default)().startOf('day').unix();
      var selectedDayUnixSec = (0, _moment2.default)(this.props.date).startOf('day').unix();

      /**
       * render date picker table body component
       * @type {array<ReactComponent>}
       */
      var bodyRows = thisMonth.map(function (week, i) {
        return _react2.default.createElement(
          'tr',
          { key: month + '-' + (i + 1) },
          _react2.default.createElement(
            'th',
            _extends({
              scope: 'row'
            }, _this4.classStyle('sr-only')),
            '\u7B2C' + (i + 1) + '\u9031'
          ),
          week.map(function (_ref) {
            var day = _ref.day,
                month = _ref.month,
                year = _ref.year,
                active = _ref.active,
                weekday = _ref.weekday,
                isHoliday = _ref.isHoliday;


            var key = 'month-day-' + year + '-' + month + '-' + day;

            var _props$highlighted$sp = _this4.props.highlighted.split('-').map(function (x) {
              return parseInt(x);
            }),
                _props$highlighted$sp2 = _slicedToArray(_props$highlighted$sp, 3),
                highlightedYear = _props$highlighted$sp2[0],
                highlightedMonth = _props$highlighted$sp2[1],
                highlightedDay = _props$highlighted$sp2[2];

            var isHighlighted = year === highlightedYear && month === highlightedMonth && day === highlightedDay;

            /**
             * deprecated
             * NOTE: これは、CSS-in-JSのようなものを試そうとした名残
             * v2.0.0では廃止して外部のライブラリ導入を目指す
             * @type {Object}
             */
            var style = _extends({}, STYLE.day, active ? STYLE.active : STYLE.notActive, STYLE[weekday], isHoliday ? STYLE.holiday : {}, _this4.isHovering(key) ? STYLE['day:hover'] : {});

            var theDayUnixSec = (0, _moment2.default)([year, month - 1, day]).unix();
            var tens = todayUnixSec < theDayUnixSec ? 'future' : todayUnixSec === theDayUnixSec ? 'today' : todayUnixSec > theDayUnixSec ? 'past' : 'tens-error';

            var relativeTens = selectedDayUnixSec < theDayUnixSec ? 'relative-future' : selectedDayUnixSec === theDayUnixSec ? 'relative-today' : selectedDayUnixSec > theDayUnixSec ? 'relative-past' : 'relative-tens-error';

            return _react2.default.createElement(
              'td',
              _extends({
                className: ['day', active ? 'active' : 'not-active', isHighlighted ? 'highlighted' : 'not-highlighted', isHoliday ? 'holiday' : 'weekday', tens, relativeTens].map(function (slug) {
                  return CLASS_PREFIX + slug;
                }).join(' '),
                key: key,
                style: style
              }, _this4.enableHover(key)),
              type === 'link' ? // exports <a> or <button>
              _react2.default.createElement(
                'a',
                _extends({
                  className: CLASS_PREFIX + 'day_' + type,
                  href: _this4.getURL(year, month, day),
                  style: _this4.isFocusing(key) ? STYLE['link:focus'] : STYLE.link
                }, _this4.enableFocus(key), {
                  onClick: function onClick() {
                    return onSelect(year, month, day);
                  }
                }),
                day
              ) : _react2.default.createElement(
                'button',
                _extends({
                  className: CLASS_PREFIX + 'day_' + type,
                  style: _this4.isFocusing(key) ? STYLE['button:focus'] : STYLE.button
                }, _this4.enableFocus(key), {
                  onClick: function onClick() {
                    return onSelect(year, month, day);
                  }
                }),
                day
              )
            );
          })
        );
      });

      // generate each style for buttons
      /**
       * ホバーしているかどうかに基づいて、先月に移動するボタンのクラスをオブジェクトの形式で生成する
       * @type {object}
       */
      var stylePrev = this.isHovering('button-prev') ? _extends({}, STYLE['navButton:hover'], STYLE.navPrev) : _extends({}, STYLE.navButton, STYLE.navPrev);
      /**
       * ホバーしているかどうかに基づいて、来月に移動するボタンのクラスをオブジェクトの形式で生成する
       * @type {object}
       */
      var styleNext = this.isHovering('button-next') ? _extends({}, STYLE['navButton:hover'], STYLE.navNext) : _extends({}, STYLE.navButton, STYLE.navNext);

      return _react2.default.createElement(
        'div',
        this.classStyle('container'),
        _react2.default.createElement(
          'nav',
          this.classStyle('navigation'),
          _react2.default.createElement(
            'button',
            _extends({
              className: CLASS_PREFIX + 'nav-button ' + CLASS_PREFIX + 'nav-prev',
              onClick: function onClick() {
                return _this4.moveMonthBackward();
              },
              style: stylePrev
            }, this.enableHover('button-prev')),
            '←'
          ),
          _react2.default.createElement(
            'button',
            _extends({
              className: CLASS_PREFIX + 'nav-button ' + CLASS_PREFIX + 'nav-next',
              onClick: function onClick() {
                return _this4.moveMonthFoward();
              },
              style: styleNext
            }, this.enableHover('button-next')),
            '→'
          )
        ),
        _react2.default.createElement(
          'div',
          this.classStyle('calender'),
          _react2.default.createElement(
            'table',
            null,
            _react2.default.createElement(
              'caption',
              this.classStyle('caption'),
              year + '\u5E74' + month + '\u6708'
            ),
            _react2.default.createElement(
              'thead',
              this.classStyle('week-labels'),
              headRow
            ),
            _react2.default.createElement(
              'tbody',
              this.classStyle('calender-grid'),
              bodyRows
            )
          )
        )
      );
    }
  }]);

  return DatePicker;
}(_react.Component);

DatePicker.defaultProps = {
  date: '',
  format: '#',
  highlighted: '',
  type: 'link',
  onSelect: function onSelect(x) {
    return x;
  } };
exports.default = DatePicker;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EYXRlUGlja2VyLmpzeCJdLCJuYW1lcyI6WyJDTEFTU19QUkVGSVgiLCJEYXRlUGlja2VyIiwicHJvcHMiLCJ0bXAiLCJkYXRlIiwiaXNWYWxpZCIsInN0YXRlIiwieWVhciIsIm1vbnRoIiwic3R5bGVzIiwiaG92ZXJpbmciLCJmb2N1c2luZyIsInNsdWciLCJyZXN1bHQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImlkIiwib25Nb3VzZUVudGVyIiwiaG92ZXJPbiIsIm9uTW91c2VMZWF2ZSIsIm9uQmx1ciIsImZvY3VzT24iLCJvbkZvY3VzIiwiZGF5IiwiZm9ybWF0Iiwic2V0U3RhdGUiLCIkc2V0IiwiblllYXIiLCJuTW9udGgiLCJ0eXBlIiwib25TZWxlY3QiLCJTVFlMRSIsImhlYWRSb3ciLCJjbGFzc1N0eWxlIiwid2Vla0xhYmVscyIsImphIiwibWFwIiwibGFiZWwiLCJ0aGlzTW9udGgiLCJ0b2RheVVuaXhTZWMiLCJzdGFydE9mIiwidW5peCIsInNlbGVjdGVkRGF5VW5peFNlYyIsImJvZHlSb3dzIiwid2VlayIsImkiLCJhY3RpdmUiLCJ3ZWVrZGF5IiwiaXNIb2xpZGF5Iiwia2V5IiwiaGlnaGxpZ2h0ZWQiLCJzcGxpdCIsInBhcnNlSW50IiwieCIsImhpZ2hsaWdodGVkWWVhciIsImhpZ2hsaWdodGVkTW9udGgiLCJoaWdobGlnaHRlZERheSIsImlzSGlnaGxpZ2h0ZWQiLCJub3RBY3RpdmUiLCJob2xpZGF5IiwiaXNIb3ZlcmluZyIsInRoZURheVVuaXhTZWMiLCJ0ZW5zIiwicmVsYXRpdmVUZW5zIiwiam9pbiIsImVuYWJsZUhvdmVyIiwiZ2V0VVJMIiwiaXNGb2N1c2luZyIsImxpbmsiLCJlbmFibGVGb2N1cyIsImJ1dHRvbiIsInN0eWxlUHJldiIsIm5hdlByZXYiLCJuYXZCdXR0b24iLCJzdHlsZU5leHQiLCJuYXZOZXh0IiwibW92ZU1vbnRoQmFja3dhcmQiLCJtb3ZlTW9udGhGb3dhcmQiLCJkZWZhdWx0UHJvcHMiXSwi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aEIsQ0FBVjtBQUVFO0FBQUE7QUFBQTtBQUVFO0FBQUE7QUFBYyxtQkFBS0EsVUFBTCxDQUFnQixTQUFoQixDQUFkO0FBQWdEMUIsa0JBQWhELGNBQXdEQyxLQUF4RDtBQUFBLGFBRkY7QUFJRTtBQUFBO0FBQVksbUJBQUt5QixVQUFMLENBQWdCLGFBQWhCLENBQVo7QUFBK0NEO0FBQS9DLGFBSkY7QUFNRTtBQUFBO0FBQVksbUJBQUtDLFVBQUwsQ0FBZ0IsZUFBaEIsQ0FBWjtBQUFpRFU7QUFBakQ7QUFORjtBQUZGO0FBbkJGLE9BREY7QUFvQ0Q7Ozs7OztBQXZVa0IxQyxVLENBa0JaNkUsWSxHQUFlO0FBQ3BCMUUsUUFBYyxFQURNO0FBRXBCb0IsVUFBYyxHQUZNO0FBR3BCMEIsZUFBYyxFQUhNO0FBSXBCckIsUUFBYyxNQUpNO0FBS3BCQyxZQUFjO0FBQUEsV0FBS3VCLENBQUw7QUFBQSxHQUxNLEU7a0JBbEJIcEQsVSIsImZpbGUiOiJEYXRlUGlja2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyAgICAgICAgICAgIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCdcbmltcG9ydCB1cGRhdGUgZnJvbSAnaW1tdXRhYmlsaXR5LWhlbHBlcidcblxuaW1wb3J0IHtcbiAgZ2V0TW9udGhDYWxlbmRhcixcbiAgbm9ybWFsaXplU3R5bGUsXG4gIHN0ckZvcm1hdCxcbiAgc25ha2UyY2FtZWwsXG59IGZyb20gJy4vY2FsYydcblxuaW1wb3J0IERFRkFVTFRfU1RZTEUgZnJvbSAnLi9zdHlsZSdcbmltcG9ydCBjb25maWcgICAgICAgIGZyb20gJy4vY29uZmlnJ1xuXG4vKipcbiAqIGludGVybmFsIGNsYXNzbmFtZSBwcmVmaXhcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBDTEFTU19QUkVGSVggPSAgJ3JlYWN0LWphLWRhdGUtcGlja2VyX18nXG5cblxuLyoqXG4gKiBEZWZpbmUgQ2FsZW5kZXIgUGlja2VyIENvbXBvbmVudFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IFJlYWN0IENvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRlUGlja2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAvKipcbiAgICogcHJvcHMgdHlwZSBjaGVja1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkYXRlICAgICAgICA6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZm9ybWF0ICAgICAgOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuY10pLFxuICAgIGhpZ2hsaWdodGVkIDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZ10pLFxuICAgIHR5cGUgICAgICAgIDogUHJvcFR5cGVzLm9uZU9mKFsnbGluaycsICdidXR0b24nXSksXG4gICAgb25TZWxlY3QgICAgOiBQcm9wVHlwZXMuZnVuYyxcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWZhdWx0IHZhbHVlcyBvZiBwcm9wc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkYXRlICAgICAgICA6ICcnLFxuICAgIGZvcm1hdCAgICAgIDogJyMnLFxuICAgIGhpZ2hsaWdodGVkIDogJycsXG4gICAgdHlwZSAgICAgICAgOiAnbGluaycsXG4gICAgb25TZWxlY3QgICAgOiB4ID0+IHgsXG4gIH1cblxuICAvKipcbiAgICogaW5pdGlhbGl6IHN0YXRlXG4gICAqIEBwdWJsaWNcbiAgICogQHBhcmFtICB7UHJvcHN9IHByb3BzIGdpdmVuIHByb3BzXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIGNvbnN0IHRtcCA9IG1vbWVudCh0aGlzLnByb3BzLmRhdGUpXG4gICAgY29uc3QgZGF0ZSA9IHRtcC5pc1ZhbGlkKCkgPyB0bXAgOiBtb21lbnQoKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB5ZWFyICAgICA6IGRhdGUueWVhcigpLFxuICAgICAgbW9udGggICAgOiBkYXRlLm1vbnRoKCkgKyAxLFxuICAgICAgc3R5bGVzICAgOiBub3JtYWxpemVTdHlsZShERUZBVUxUX1NUWUxFKSxcbiAgICAgIGhvdmVyaW5nIDogZmFsc2UsXG4gICAgICBmb2N1c2luZyA6IGZhbHNlLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZW5lcmF0ZSBzdGF0aWMgY2xhc3NOYW1lIGFuZCBzdHlsZSBvYmplY3RzXG4gICAqIEBwYXJhbSAge2FycmF5PHN0cmluZz58c3RyaW5nfSBzbHVnIHlvdXIgc2x1ZyBpbiBzbmFrZS1jYXNlXG4gICAqIEByZXR1cm4ge3tjbGFzc05hbWU6c3RyaW5nLHN0eWxlOmNzc0luSnN9fSBnZW5lcmF0ZWQgb2JqZWN0XG4gICAqL1xuICBjbGFzc1N0eWxlKHNsdWcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBjbGFzc05hbWUgOiBDTEFTU19QUkVGSVggKyBzbHVnLFxuICAgICAgc3R5bGUgICAgIDogdGhpcy5zdGF0ZS5zdHlsZXNbc25ha2UyY2FtZWwoc2x1ZyldXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBtYW5hZ2UgaG92ZXIgc3RhdHVzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgaWRcbiAgICogQHJldHVybiB7e29uTW91c2VFbnRlcjpmdW5jdGlvbixvbk1vdXNlTGVhdmU6ZnVuY3Rpb259fSAgZXZlbnRIYW5kbGVyc1xuICAgKi9cbiAgZW5hYmxlSG92ZXIoaWQpIHtcbiAgICByZXR1cm4gKHtcbiAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gdGhpcy5ob3Zlck9uKGlkKSxcbiAgICAgIG9uTW91c2VMZWF2ZTogKCkgPT4gdGhpcy5ob3Zlck9uKGZhbHNlKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogbWFuYWdlIGZvY3VzIHN0YXR1c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIGlkXG4gICAqIEByZXR1cm4ge3tvbkJsdXI6ZnVuY3Rpb24sb25Gb2N1czpmdW5jdGlvbn19ICBldmVudEhhbmRsZXJzXG4gICAqL1xuICBlbmFibGVGb2N1cyhpZCkge1xuICAgIHJldHVybiAoe1xuICAgICAgb25CbHVyICA6ICgpID0+IHRoaXMuZm9jdXNPbihmYWxzZSksXG4gICAgICBvbkZvY3VzIDogKCkgPT4gdGhpcy5mb2N1c09uKGlkKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogZm9ybWF0IHByb3Agb3ZlcmxvYWQgd2l0aCB7c3RyaW5nfSBvciB7ZnVuY3Rpb259XG4gICAqIEBwYXJhbSAge251bWJlcn0geWVhciAgeWVhclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG1vbnRoIG1vbnRoXG4gICAqIEBwYXJhbSAge251bWJlcn0gZGF5IGRheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBhaW1lZCBVUkwgc3RyaW5nXG4gICAqL1xuICBnZXRVUkwoeWVhciwgbW9udGgsIGRheSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiB0aGlzLnByb3BzLmZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBmb3JtYXQoeWVhciwgbW9udGgsIGRheSkgOiAvLyB1c2UgaXQgYXMgaXQgaXNcbiAgICAgIHN0ckZvcm1hdCh0aGlzLnByb3BzLmZvcm1hdCwgeyB5ZWFyLCBtb250aCwgZGF5IH0pIC8vIHVzZSBlbWJlZGRlZFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGVjayBpZiBhIGVsZW1lbnQgd2l0aCBjZXJ0YWluIGlkIGlzIGJlaW5nIGhvdmVyZWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgaWQgIGdpdmVuIGlkXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICB3aGV0aGVyIGhvdmVycmluZ1xuICAgKi9cbiAgaXNIb3ZlcmluZyhpZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID8gdGhpcy5zdGF0ZS5ob3ZlcmluZyA9PT0gaWQgOiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGEgZWxlbG1lbnQgd2l0aCBjZXJ0YWluIGlkIGlzIGJlaW5nIGZvY3VzZWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgaWQgZ2l2ZW4gaWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgd2hldGhlciBmb2N1c2luZ1xuICAgKi9cbiAgaXNGb2N1c2luZyhpZCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlID8gdGhpcy5zdGF0ZS5mb2N1c2luZyA9PT0gaWQgOiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBjYWxsYmFjayB0byBzZXQgaG92ZXJpcm5nIHN0YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ3xib29sZWFufSBpZCBnaXZpbmcgaWQsIG9yIGZhbHNlIHRvIGNhbmNlbCBpdFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgaG92ZXJPbihpZCkge1xuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlKHRoaXMuc3RhdGUsIHsgaG92ZXJpbmc6IHsgJHNldDogaWQgfSB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBjcmVhdGUgY2FsbGJhY2sgdG8gc2V0IGZvY3VzaW5nIHN0YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ3xib29sZWFufSBpZCBnaXZpbmcgaWQsIG9yIGZhbHNlIHRvIGNhbmNlbCBpdFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgZm9jdXNPbihpZCkge1xuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlKHRoaXMuc3RhdGUsIHsgZm9jdXNpbmc6IHsgJHNldDogaWQgfSB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGFuZ2UgbmV4dCBtb250aFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgbW92ZU1vbnRoRm93YXJkKCkge1xuICAgIGNvbnN0IG5ZZWFyID0gKHRoaXMuc3RhdGUubW9udGggKyAxID4gMTIgPyB0aGlzLnN0YXRlLnllYXIgKyAxIDogdGhpcy5zdGF0ZS55ZWFyKVxuICAgIGNvbnN0IG5Nb250aCA9ICh0aGlzLnN0YXRlLm1vbnRoID09IDEyID8gMSA6IHRoaXMuc3RhdGUubW9udGggKyAxKVxuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlKHRoaXMuc3RhdGUsIHsgeWVhcjogeyAkc2V0OiBuWWVhciB9LCBtb250aDogeyAkc2V0OiBuTW9udGggfSB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGFuZ2UgcHJldiBtb250aFxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgbW92ZU1vbnRoQmFja3dhcmQoKSB7XG4gICAgY29uc3QgblllYXIgPSAodGhpcy5zdGF0ZS5tb250aCAtIDEgPT0gMCA/IHRoaXMuc3RhdGUueWVhciAtIDEgOiB0aGlzLnN0YXRlLnllYXIpXG4gICAgY29uc3Qgbk1vbnRoID0gKHRoaXMuc3RhdGUubW9udGggLSAxID09IDAgPyAxMiA6IHRoaXMuc3RhdGUubW9udGggLSAxKVxuICAgIHRoaXMuc2V0U3RhdGUodXBkYXRlKHRoaXMuc3RhdGUsIHsgeWVhcjogeyAkc2V0OiBuWWVhciB9LCBtb250aDogeyAkc2V0OiBuTW9udGggfSB9KSlcbiAgfVxuXG4gIC8qKlxuICAgKiByZW5kZXJcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHJlbmRlciBhIGNhbGVuZGVyIHBpY2tlclxuICAgKi9cbiAgcmVuZGVyKCkge1xuXG4gICAgLy8gcGFyc2UgcHJvcHNcbiAgICBjb25zdCB0eXBlICAgICA9IHRoaXMucHJvcHMudHlwZVxuICAgIGNvbnN0IG9uU2VsZWN0ID0gdGhpcy5wcm9wcy5vblNlbGVjdFxuXG4gICAgLy8gcGFyc2Ugc3R5bGUgb2JqZWN0XG4gICAgY29uc3QgU1RZTEUgPSBub3JtYWxpemVTdHlsZShERUZBVUxUX1NUWUxFKVxuXG4gICAgLy8gcGFyc2Ugc3RhdGVcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoIH0gPSB0aGlzLnN0YXRlXG5cbiAgICAvKipcbiAgICAgKiByZW5kZXIgd2VlayBsYWJlbHMgYXMgZGF0ZSBwaWNrZXIgdGFibGUgaGVhZCBjb21wb25lbnRcbiAgICAgKiBAdHlwZSB7YXJyYXk8UmVhY3RDb21wb25lbnQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGhlYWRSb3cgPSA8dHI+XG4gICAgICA8dGhcbiAgICAgICAgc2NvcGU9eyAncm93JyB9XG4gICAgICAgIHsgLi4udGhpcy5jbGFzc1N0eWxlKCdzci1vbmx5JykgfVxuICAgICAgPnsgJ+mAsScgfTwvdGg+XG5cbiAgICAgIHsgY29uZmlnLndlZWtMYWJlbHMuamEubWFwKGxhYmVsID0+IDx0aFxuICAgICAgICBrZXk9eyAnd2Vla2xhYmVsLScgKyBsYWJlbCB9XG4gICAgICAgIHNjb3BlPXsgJ2NvbCcgfVxuICAgICAgICB7IC4uLnRoaXMuY2xhc3NTdHlsZSgnd2Vlay1sYWJlbCcpIH1cbiAgICAgID57IGxhYmVsIH08L3RoPlxuICAgICAgKSB9XG5cbiAgICA8L3RyPlxuXG4gICAgLyoqXG4gICAgICog5b2T5pyI44Gu5pel44Gu5oOF5aCx44KS44G+44Go44KB44Gf44Kq44OW44K444Kn44Kv44OI44KS5Ye65Yqb44GZ44KLXG4gICAgICogQHR5cGUge2FycmF5PGFycmF5PHtkYXk6bnVtYmVyLG1vbnRoOm51bWJlcixhY3RpdmU6Ym9vbGVhbix3ZWVrZGF5OnN0cmluZyxpc0hvbGlkYXk6Ym9vbGVhbn0+Pn1cbiAgICAgKi9cbiAgICBjb25zdCB0aGlzTW9udGggPSBnZXRNb250aENhbGVuZGFyKHllYXIsIG1vbnRoKVxuICAgIGNvbnN0IHRvZGF5VW5peFNlYyA9IG1vbWVudCgpLnN0YXJ0T2YoJ2RheScpLnVuaXgoKVxuICAgIGNvbnN0IHNlbGVjdGVkRGF5VW5peFNlYyA9IG1vbWVudCh0aGlzLnByb3BzLmRhdGUpLnN0YXJ0T2YoJ2RheScpLnVuaXgoKVxuXG4gICAgLyoqXG4gICAgICogcmVuZGVyIGRhdGUgcGlja2VyIHRhYmxlIGJvZHkgY29tcG9uZW50XG4gICAgICogQHR5cGUge2FycmF5PFJlYWN0Q29tcG9uZW50Pn1cbiAgICAgKi9cbiAgICBjb25zdCBib2R5Um93cyA9IHRoaXNNb250aC5tYXAoKHdlZWssIGkpID0+IDx0ciBrZXk9eyBgJHttb250aH0tJHtpICsgMX1gIH0+XG4gICAgICA8dGhcbiAgICAgICAgc2NvcGU9eyAncm93JyB9XG4gICAgICAgIHsgLi4udGhpcy5jbGFzc1N0eWxlKCdzci1vbmx5JykgfVxuICAgICAgPnsgYOesrCR7aSArIDF96YCxYCB9PC90aD5cblxuICAgICAgeyB3ZWVrLm1hcCgoeyBkYXksIG1vbnRoLCB5ZWFyLCBhY3RpdmUsIHdlZWtkYXksIGlzSG9saWRheSB9KSA9PiB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gYG1vbnRoLWRheS0ke3llYXJ9LSR7bW9udGh9LSR7ZGF5fWBcbiAgICAgICAgY29uc3QgW1xuICAgICAgICAgIGhpZ2hsaWdodGVkWWVhcixcbiAgICAgICAgICBoaWdobGlnaHRlZE1vbnRoLFxuICAgICAgICAgIGhpZ2hsaWdodGVkRGF5LFxuICAgICAgICBdID0gdGhpcy5wcm9wcy5oaWdobGlnaHRlZC5zcGxpdCgnLScpLm1hcCh4ID0+IHBhcnNlSW50KHgpKVxuXG4gICAgICAgIGNvbnN0IGlzSGlnaGxpZ2h0ZWQgPVxuICAgICAgICAgIHllYXIgID09PSBoaWdobGlnaHRlZFllYXIgJiZcbiAgICAgICAgICBtb250aCA9PT0gaGlnaGxpZ2h0ZWRNb250aCAmJlxuICAgICAgICAgIGRheSAgID09PSBoaWdobGlnaHRlZERheVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkZXByZWNhdGVkXG4gICAgICAgICAqIE5PVEU6IOOBk+OCjOOBr+OAgUNTUy1pbi1KU+OBruOCiOOBhuOBquOCguOBruOCkuippuOBneOBhuOBqOOBl+OBn+WQjeaui1xuICAgICAgICAgKiB2Mi4wLjDjgafjga/lu4PmraLjgZfjgablpJbpg6jjga7jg6njgqTjg5bjg6njg6rlsI7lhaXjgpLnm67mjIfjgZlcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgICAgIC4uLlNUWUxFLmRheSwgLy8g5pmu6YCa44Gu44KE44GkXG4gICAgICAgICAgLi4uKGFjdGl2ZSA/IFNUWUxFLmFjdGl2ZSA6IFNUWUxFLm5vdEFjdGl2ZSksICAgICAvLyDmtLvkuI3mtLtcbiAgICAgICAgICAuLi4oU1RZTEVbd2Vla2RheV0pLCAgICAgICAgICAgICAgICAgLy8g6YCx5pelXG4gICAgICAgICAgLi4uKGlzSG9saWRheSA/IFNUWUxFLmhvbGlkYXkgOiB7fSksIC8vIOelneaXpVxuICAgICAgICAgIC4uLih0aGlzLmlzSG92ZXJpbmcoa2V5KSA/IFNUWUxFWydkYXk6aG92ZXInXSA6IHt9KSwgLy8g44Ob44OQ44O844GX44Gm44GE44KL5pmCXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGVEYXlVbml4U2VjID0gbW9tZW50KFt5ZWFyLCBtb250aCAtIDEsIGRheV0pLnVuaXgoKVxuICAgICAgICBjb25zdCB0ZW5zID1cbiAgICAgICAgICB0b2RheVVuaXhTZWMgPCB0aGVEYXlVbml4U2VjID8gJ2Z1dHVyZScgOlxuICAgICAgICAgIHRvZGF5VW5peFNlYyA9PT0gdGhlRGF5VW5peFNlYyA/ICd0b2RheScgOlxuICAgICAgICAgIHRvZGF5VW5peFNlYyA+IHRoZURheVVuaXhTZWMgPyAncGFzdCcgOiAndGVucy1lcnJvcidcblxuICAgICAgICBjb25zdCByZWxhdGl2ZVRlbnMgPVxuICAgICAgICAgIHNlbGVjdGVkRGF5VW5peFNlYyA8IHRoZURheVVuaXhTZWMgPyAncmVsYXRpdmUtZnV0dXJlJyA6XG4gICAgICAgICAgc2VsZWN0ZWREYXlVbml4U2VjID09PSB0aGVEYXlVbml4U2VjID8gJ3JlbGF0aXZlLXRvZGF5JyA6XG4gICAgICAgICAgc2VsZWN0ZWREYXlVbml4U2VjID4gdGhlRGF5VW5peFNlYyA/ICdyZWxhdGl2ZS1wYXN0JyA6ICdyZWxhdGl2ZS10ZW5zLWVycm9yJ1xuXG4gICAgICAgIHJldHVybiAoPHRkXG4gICAgICAgICAgY2xhc3NOYW1lPXsgW1xuICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAoYWN0aXZlICAgICAgICA/ICdhY3RpdmUnICAgICAgOiAnbm90LWFjdGl2ZScpLFxuICAgICAgICAgICAgKGlzSGlnaGxpZ2h0ZWQgPyAnaGlnaGxpZ2h0ZWQnIDogJ25vdC1oaWdobGlnaHRlZCcpLFxuICAgICAgICAgICAgKGlzSG9saWRheSAgICAgPyAnaG9saWRheScgICAgIDogJ3dlZWtkYXknKSxcbiAgICAgICAgICAgIHRlbnMsXG4gICAgICAgICAgICByZWxhdGl2ZVRlbnMsXG4gICAgICAgICAgXS5tYXAoc2x1ZyA9PiBDTEFTU19QUkVGSVggKyBzbHVnKS5qb2luKCcgJykgfVxuICAgICAgICAgIGtleT17IGtleSB9XG4gICAgICAgICAgc3R5bGU9eyBzdHlsZSB9XG4gICAgICAgICAgeyAuLi50aGlzLmVuYWJsZUhvdmVyKGtleSkgfVxuICAgICAgICA+eyB0eXBlID09PSAnbGluaycgPyAvLyBleHBvcnRzIDxhPiBvciA8YnV0dG9uPlxuICAgICAgICAgIDxhXG4gICAgICAgICAgICBjbGFzc05hbWU9eyBDTEFTU19QUkVGSVggKyAnZGF5XycgKyB0eXBlIH1cbiAgICAgICAgICAgIGhyZWY9eyB0aGlzLmdldFVSTCh5ZWFyLCBtb250aCwgZGF5KSB9XG4gICAgICAgICAgICBzdHlsZT17IHRoaXMuaXNGb2N1c2luZyhrZXkpID8gU1RZTEVbJ2xpbms6Zm9jdXMnXSA6IFNUWUxFLmxpbmsgfVxuICAgICAgICAgICAgeyAuLi50aGlzLmVuYWJsZUZvY3VzKGtleSkgfVxuICAgICAgICAgICAgb25DbGljaz17ICgpID0+IG9uU2VsZWN0KHllYXIsIG1vbnRoLCBkYXkpIH1cbiAgICAgICAgICA+eyBkYXkgfTwvYT4gOlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17IENMQVNTX1BSRUZJWCArICdkYXlfJyArIHR5cGUgfVxuICAgICAgICAgICAgc3R5bGU9eyB0aGlzLmlzRm9jdXNpbmcoa2V5KSA/IFNUWUxFWydidXR0b246Zm9jdXMnXSA6IFNUWUxFLmJ1dHRvbiB9XG4gICAgICAgICAgICB7IC4uLnRoaXMuZW5hYmxlRm9jdXMoa2V5KSB9XG4gICAgICAgICAgICBvbkNsaWNrPXsgKCkgPT4gb25TZWxlY3QoeWVhciwgbW9udGgsIGRheSkgfVxuICAgICAgICAgID57IGRheSB9PC9idXR0b24+XG5cbiAgICAgICAgfTwvdGQ+KVxuICAgICAgfSkgfVxuICAgIDwvdHI+KVxuXG4gICAgLy8gZ2VuZXJhdGUgZWFjaCBzdHlsZSBmb3IgYnV0dG9uc1xuICAgIC8qKlxuICAgICAqIOODm+ODkOODvOOBl+OBpuOBhOOCi+OBi+OBqeOBhuOBi+OBq+WfuuOBpeOBhOOBpuOAgeWFiOaciOOBq+enu+WLleOBmeOCi+ODnOOCv+ODs+OBruOCr+ODqeOCueOCkuOCquODluOCuOOCp+OCr+ODiOOBruW9ouW8j+OBp+eUn+aIkOOBmeOCi1xuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uc3Qgc3R5bGVQcmV2ID0gdGhpcy5pc0hvdmVyaW5nKCdidXR0b24tcHJldicpID9cbiAgICAgIHsgLi4uU1RZTEVbJ25hdkJ1dHRvbjpob3ZlciddLCAuLi5TVFlMRS5uYXZQcmV2IH0gOlxuICAgICAgeyAuLi5TVFlMRS5uYXZCdXR0b24sICAgICAgICAgIC4uLlNUWUxFLm5hdlByZXYgfVxuICAgICAgLyoqXG4gICAgICAgKiDjg5vjg5Djg7zjgZfjgabjgYTjgovjgYvjganjgYbjgYvjgavln7rjgaXjgYTjgabjgIHmnaXmnIjjgavnp7vli5XjgZnjgovjg5zjgr/jg7Pjga7jgq/jg6njgrnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjga7lvaLlvI/jgafnlJ/miJDjgZnjgotcbiAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgKi9cbiAgICBjb25zdCBzdHlsZU5leHQgPSB0aGlzLmlzSG92ZXJpbmcoJ2J1dHRvbi1uZXh0JykgP1xuICAgICAgeyAuLi5TVFlMRVsnbmF2QnV0dG9uOmhvdmVyJ10sIC4uLlNUWUxFLm5hdk5leHQgfSA6XG4gICAgICB7IC4uLlNUWUxFLm5hdkJ1dHRvbiwgICAgICAgICAgLi4uU1RZTEUubmF2TmV4dCB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiB7IC4uLnRoaXMuY2xhc3NTdHlsZSgnY29udGFpbmVyJykgfT5cblxuICAgICAgICA8bmF2IHsgLi4udGhpcy5jbGFzc1N0eWxlKCduYXZpZ2F0aW9uJykgfT5cblxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT17IENMQVNTX1BSRUZJWCArICduYXYtYnV0dG9uICcgKyBDTEFTU19QUkVGSVggKyAnbmF2LXByZXYnIH1cbiAgICAgICAgICAgIG9uQ2xpY2s9eyAoKSA9PiB0aGlzLm1vdmVNb250aEJhY2t3YXJkKCkgfVxuICAgICAgICAgICAgc3R5bGU9eyBzdHlsZVByZXYgfVxuICAgICAgICAgICAgeyAuLi50aGlzLmVuYWJsZUhvdmVyKCdidXR0b24tcHJldicpIH1cbiAgICAgICAgICA+eyAn4oaQJyB9PC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPXsgQ0xBU1NfUFJFRklYICsgJ25hdi1idXR0b24gJyArIENMQVNTX1BSRUZJWCArICduYXYtbmV4dCcgfVxuICAgICAgICAgICAgb25DbGljaz17ICgpID0+IHRoaXMubW92ZU1vbnRoRm93YXJkKCkgfVxuICAgICAgICAgICAgc3R5bGU9eyBzdHlsZU5leHQgfVxuICAgICAgICAgICAgeyAuLi50aGlzLmVuYWJsZUhvdmVyKCdidXR0b24tbmV4dCcpIH1cbiAgICAgICAgICA+eyAn4oaSJyB9PC9idXR0b24+XG5cbiAgICAgICAgPC9uYXY+XG5cbiAgICAgICAgPGRpdiB7IC4uLnRoaXMuY2xhc3NTdHlsZSgnY2FsZW5kZXInKSB9PlxuXG4gICAgICAgICAgPHRhYmxlPlxuXG4gICAgICAgICAgICA8Y2FwdGlvbiB7IC4uLnRoaXMuY2xhc3NTdHlsZSgnY2FwdGlvbicpIH0+eyBgJHt5ZWFyfeW5tCR7bW9udGh95pyIYCB9PC9jYXB0aW9uPlxuXG4gICAgICAgICAgICA8dGhlYWQgeyAuLi50aGlzLmNsYXNzU3R5bGUoJ3dlZWstbGFiZWxzJykgfT57IGhlYWRSb3cgfTwvdGhlYWQ+XG5cbiAgICAgICAgICAgIDx0Ym9keSB7IC4uLnRoaXMuY2xhc3NTdHlsZSgnY2FsZW5kZXItZ3JpZCcpIH0+eyBib2R5Um93cyB9PC90Ym9keT5cblxuICAgICAgICAgIDwvdGFibGU+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuIl19